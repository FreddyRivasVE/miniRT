### âœ… Â¿QuÃ© significa **normalizar** un vector en `MiniRT`?

**Normalizar un vector** es transformarlo para que **mantenga su direcciÃ³n** pero tenga **longitud 1**.

Esto se hace mucho en raytracing para trabajar con **direcciones puras**, sin que la magnitud (el largo) del vector afecte las cuentas (como iluminaciÃ³n o rebotes).

### ğŸ¯ **MetÃ¡fora: "La direcciÃ³n del camino, no la distancia"**

ImaginÃ¡ que estÃ¡s parada en un punto del mapa y querÃ©s indicar **en quÃ© direcciÃ³n estÃ¡ una montaÃ±a** â›°ï¸.

* PodÃ©s seÃ±alar con un palo de **3 metros** apuntando hacia ella.
* O con un palito de **30 cm** apuntando igual.

â— Lo que importa no es **cuÃ¡n largo es el palo**, sino **hacia dÃ³nde apunta**.

---

### âœ¨ Entonces...

**Normalizar** ese palo serÃ­a **acortarlo** a una **longitud fija de 1 metro**, **sin cambiar la direcciÃ³n**.

* AsÃ­ podÃ©s comparar muchas direcciones sin preocuparte por el largo del palo.
* Todos los palos apuntan a distintos lugares, pero **miden lo mismo** â†’ eso es normalizar.

---

### ğŸ’» En `MiniRT`:

* TenÃ©s un vector `(3, 0, 4)` â†’ es como un palo que apunta a cierta direcciÃ³n, con una longitud de 5.
* Lo **normalizÃ¡s** â†’ ahora es `(0.6, 0.0, 0.8)`, que **apunta igual**, pero mide 1.

---

### ğŸ“¦ Resumen de la metÃ¡fora:

> â€œNormalizar un vector es como recortar un palo que apunta a una montaÃ±a para que mida exactamente 1 metro, sin cambiar a dÃ³nde apunta.â€

---

### ğŸ§® Ejemplo con `t_vec4`:

Supongamos que tenÃ©s:

```c
t_vec4 v = {3.0f, 0.0f, 4.0f, 0.0f};
```

> RecordÃ¡: si `t_vec4` es un vector de 4 `floats`, el cuarto componente (`w`) lo podÃ©s dejar en 0 para vectores (o en 1 para puntos si hacÃ©s transformaciÃ³nes homogÃ©neas, pero eso es mÃ¡s avanzado).

---

### 1. CalculÃ¡s la **longitud** del vector:

```c
float len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
// len = sqrt(3Â² + 0Â² + 4Â²) = sqrt(9 + 0 + 16) = sqrt(25) = 5
```

---

### 2. NormalizÃ¡s cada componente:

```c
t_vec4 norm_v = {v[0]/len, v[1]/len, v[2]/len, 0.0f};
// norm_v = (0.6, 0.0, 0.8, 0.0)
```

Ahora ese nuevo vector **apunta igual**, pero su **longitud es exactamente 1**.

---

### ğŸ§  Â¿Por quÃ© sirve?

* En iluminaciÃ³n: usÃ¡s vectores normalizados para calcular la luz que incide en un punto (producto escalar, reflejos, etc.).
* En geometrÃ­a: normalizÃ¡s la direcciÃ³n del rayo o de la normal de una superficie.

---

### ğŸ› ï¸ Â¿QuerÃ©s una funciÃ³n `normalize()` en C?

```c
t_vec4	normalize(t_vec4 v)
{
	float	len = sqrtf(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
	if (len == 0.0f)
		return (t_vec4){0.0f, 0.0f, 0.0f, 0.0f};
	return (t_vec4){v[0]/len, v[1]/len, v[2]/len, 0.0f};
}
```

ğŸ§¯ **Siempre chequeÃ¡ que el vector no tenga longitud 0**, porque no podÃ©s dividir por 0.

---

Â¿QuerÃ©s que tambiÃ©n escribamos una `length()` para que quede separado?

